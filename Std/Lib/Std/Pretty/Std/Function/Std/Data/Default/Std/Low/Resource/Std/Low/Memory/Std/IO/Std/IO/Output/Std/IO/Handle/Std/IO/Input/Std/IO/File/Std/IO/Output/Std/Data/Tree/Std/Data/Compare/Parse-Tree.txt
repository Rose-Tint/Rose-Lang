

impl <> Logical Boolean  {
    ^^ [(False )] b {
        return(b;);
    }
    ^^ [(True )] b {
        return((not b););
    }
    || [(False )] b {
        return(b;);
    }
    || [(True )] b {
        return((True ););
    }
    && [(False )] b {
        return((False ););
    }
    && [(True )] b {
        return(b;);
    }
    asBool b {
        return(b;);
    }
}
impl <> Logical Int  {
    asBool n {
        return((True ););
    }
    asBool [0] {
        return((False ););
    }
}
impl <> Logical  {
    not  {
        return((. not asBool););
    }
    ^^ a b {
        return((^^ (asBool a) (asBool b)););
    }
    || a b {
        return((|| (asBool a) (asBool b)););
    }
    && a b {
        return((&& (asBool a) (asBool b)););
    }
}
impl <> Ord  {
    >= a b {
        return((|| (> a b) (== a b)););
    }
    >  {
        return((. not <=););
    }
    <= a b {
        return((|| (< a b) (== a b)););
    }
    <  {
        return((. not >=););
    }
}
clamp lo hi {
    return((. (min hi) (max lo)););
}
pure export clamp<Ord a: (a  a  a  a )>
max a b {
    match ((<=> a b)) {
        _ {
            return(b;);
        }
        [(GT )] {
            return(a;);
        }
    }
}
pure export max<Ord a: (a  a  a )>
min a b {
    match ((<=> a b)) {
        _ {
            return(a;);
        }
        [(GT )] {
            return(b;);
        }
    }
}
pure export min<Ord a: (a  a  a )>
export trait <> Logical a {
    pure export not<(a  Boolean )>
    pure export ^^<(a  a  Boolean )>
    pure export ||<(a  a  Boolean )>
    pure export &&<(a  a  Boolean )>
    pure export asBool<(a  Boolean )>
}
export trait <> Ord a {
    pure export <=><(a  a  Ordering )>
    pure export >=<(a  a  Boolean )>
    pure export ><(a  a  Boolean )>
    pure export <=<(a  a  Boolean )>
    pure export <<(a  a  Boolean )>
}
export trait <> Eq a {
    pure export ==<(a  a  Boolean )>
    pure export ==<(a  a  Boolean )>
}
export data Ordering     = GT export
    | EQ export
    | LT export


