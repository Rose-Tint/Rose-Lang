(* TODO: update parser for:
    pragmas,
    if-else,
    case,
*)

module-header       = "module", big-ident, "where"
top-level-decl      = pragma-seq
                    | func-decl | func-def
                    | data-def | type-alias
                    | trait-decl | trait-impl
module              = module-header, {import}, {top-level-decl}

(* LITERALS: *)
oct-digit           = #"[0-8]"
digit               = #"[0-9]"
hex-digit           = #"[0-9a-fA-F]"
binary              = ("b"|"B"), ("0"|"1"), {("0"|"1")}
octal               = ("o"|"O"), oct-digit, {oct-digit}
hexa                = ("x"|"X"), hex-digit, {hex-digit}
decimal             = digit, {digit}
sign                = "-" | "+"
integer             = [sign], decimal
                    | [sign], "0", (binary | octal | hexa)
exponent            = ["."], ("e"|"E"), [sign], decimal
hex-exponent        = ["."], ("p"|"P"), [sign], decimal
float               = [sign], decimal, exponent, ["f"]
                    | [sign], decimal, exponent, ["f"]
                    | [sign], decimal, ".", decimal, ["f"]
                    | [sign], hexa, hex-exponent, ["f"]
char                = "'", character, "'"
special             = #"[\\abfnrtv'\"]"
character           = "//", (hexa | octal | special) | ? ANY CHAR ?
string              = """, {character}, """
literal             = integer | float | char | string | array


(* IMPORTING: *)
(* TODO: add a "hiding" option *)
import-item         = "trait", big-ident, [ "{", [func-imp-list], "}" ]
                    | "data", big-ident, [ "{", [ctor-imp-list], "}" ]
                    | prefix-ident
import              = "import", visib, big-ident, [ "as", big-ident ], [ "using",
                        "{", {import-item}, "}" ]


(* IDENTIFIERS: *)
qualifier           = #"([A-Z][a-zA-Z0-9]*\.)*"
big-ident           = qualifier, #"[A-Z][a-zA-Z0-9_]*"
small-ident         = qualifier, #"[a-z_][a-zA-Z0-9_]*"
symbol              = #"(~!@#\$%^&\*-\+=\\\|:<>\.\?/)+"
operator            = qualifer, symbol - "=", [small-ident], [symbol]
infix-ident         = operator | "`", small-ident, "`"
prefix-ident        = small-ident | "(", operator, ")"
identifier          = small-ident | big-ident | "(", operator, ")"


(* PRAGMAS: *)
allow-unused        = "allow_unused","(", identifier, ")"
warn-unused         = "warn_unused","(", prefix-ident, ")"
inline              = "inline","(", prefix-ident, ")"
deprecated          = "deprecated","(", identifier, [ ",", string ] ")"
test                = "test","(", identifier, ")"
pragma              = "#","[", directive, "]"
pragma-seq          = "#","[", directive, { ",", directive }, "]"
directive           = allow-unused
                    | warn-unused
                    | inline
                    | cold
                    | deprecated
                    | test
heat-pragma         = "#","[", ("cold"|"warm"), "]"


(* DECLARATION SPECIFIERS: *)
visib               = ["extern"] | ["intern"]
purity              = "pure" | "unsafe" | "impure"
mutab               = ["mut"] | ["imut"]


(* TYPES: *)
type                = "[", type, "]"
                    | big-ident, {type}
                    | small-ident, {type}
                    | "(", type, ",", type, { ",", type } ")"
                    | "(", type, { "->", type }, ")"
constraint          = big-ident, small-ident, {small-ident}
ctx-decl-seq        = constraint, { ",", constraint }, ":"
type-decl-no-ctx    = "<", type, { "->", type }, ">"
type-decl           = "<", [ctx-decl-seq], type, { "->", type }, ">"


(* FUNCTION DEFINITION: *)
func-decl           = visib, purity, prefix-ident, type-decl
infix-param-seq     = pattern, infix-ident, pattern
prefix-param-seq    = prefix-ident, {pattern}
func-param-seq      = infix-param-seq | prefix-param-seq
func-def            = func-param-seq, body-assignment


(* DATATYPE DEFINITION: *)
field-decl          = small-ident, type-decl
ctor-def            = visib, big-ident, {type}
                    | visib, big-ident, [ "{", field-decl, { ",", field-decl }, [","], "}" ]
data-def            = visib, "data", big-ident, "=", ctor-def, { "|", ctor-def }
type-alias          = visib, "using", type, "=", type


(* TRAIT DEFINITION: *)
trait-ctx           = "<", constraint, { ",", constraint }, ">"
trait-decl          = visib, "trait", [trait-ctx], big-ident, small-ident, {small-ident},
                        "{", {(func-decl | func-def)}, "}"
trait-impl          = "impl", [trait-ctx], big-ident, type, {type},
                        "{", {func-decl}, "}"


(* TERMS: *)
term                = literal
                    | lambda
                    | ctor-call
                    | func-call
                    | "(", term, ")"
(* for now, lambas will be extremely limited due to
it needing `statement` or `body`, which needs `term`
(and thus `lambda'), causing a circular import. Also,
maybe it should have a unique-ish prefix for efficiency? *)
lambda              = {small-ident}, "=>", term
infix-call          = term, infix-ident, term
                    | infix-ident, term
                    | term, infix-ident
ctor-call           = big-ident, {term}
func-call           = infix-call
                    | small-ident, {term}
                    | "(", operator, ")", {term}
                    | "(", func-call, ")", {term}
                    | "(", lambda, ")", {term}
tuple               = "(", term, ",", term, { ",", term }, ")"
array               = "[", {term}, "]"


(* PATTERNS *)
ctor-pattern        = big-ident, {pattern}
tuple-pattern       = "(", pattern, ",", pattern, { ",", pattern }, ")"
pattern-item        = literal | tuple-pattern | ctor-pattern
pattern             = "_" | small-ident | "[", pattern-item, { ",", pattern-item }, "]"


(* STATEMENTS: *)
statement           = if-else | match | return | loop | new-var, ";" | reassignment, ";"
body                = "{", {statement}, "}"
body-assignment     = "=", statement | body
stmt-body           = statement | body
if-else             = "if", [heat-pragma], "(", term, ")", stmt-body,
                        [ "else", [heat-pragma], stmt-body ]
return              = "return", ( term, ";" | match | if-else )
case                = [heat-pragma], pattern, body-assignment
match               = "match","(", term, ")","{", case, {case}, "}"
loop-clause         = "(", [statement], ";", statement, ";", [statement], ")"
                    | "(", statement, ")"
loop                = "loop", loop-clause, stmt-body
var-decl-seq        = "let", mutab, small-ident, [type-decl]
assignment          = "=", term
new-var             = var-decl-seq, assignment
reassignment        = small-ident, assignment
