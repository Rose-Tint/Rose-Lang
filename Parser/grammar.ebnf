(* TODO: update parser for:
    pragmas,
    if-else,
    case,
*)

(* LITERALS: *)
oct-digit           = ? REGEX "[0-8]" ?;
digit               = ? REGEX "[0-9]" ?;
hex-digit           = ? REGEX "[0-9a-fA-F]" ?;
binary              = ("b"|"B"), ("0"|"1"), {("0"|"1")};
octal               = ("o"|"O"), oct-digit, {oct-digit};
hexa                = ("x"|"X"), hex-digit, {hex-digit};
decimal             = digit, {digit};
sign                = "-" | "+";
integer             = [sign], decimal
                    | [sign], "0", (binary | octal | hexa);
exponent            = ["."], ("e"|"E"), [sign], decimal;
hex-exponent        = ["."], ("p"|"P"), [sign], decimal;
float               = [sign], decimal, exponent, ["f"]
                    | [sign], decimal, exponent, ["f"]
                    | [sign], decimal, ".", decimal, ["f"]
                    | [sign], hexa, hex-exponent, ["f"]
char                = "'", character, "'";
special             = ? REGEX "[\\abfnrtv'\"]" ?;
character           = "//", (hexa | octal | special) | ? ANY CHAR ?;
string              = """, {character}, """;
literal             = integer | float | char | string | array;


(* IMPORTING: *)
(* TODO: add a "hiding" option *)
import-item         = "trait", big-ident, [ "{", [func-imp-list], "}" ];
                    | "data", big-ident, [ "{", [ctor-imp-list], "}" ];
                    | prefix-ident
module-import       = "import", visib, big-ident, [ "as", big-ident ], [ "using",
                        "{", {import-item}, "}" ];


(* IDENTIFIERS: *)
qualifier           = ? REGEX "([A-Z][a-zA-Z0-9]*\.)*" ?;
big-ident           = qualifier, ? REGEX "[A-Z][a-zA-Z0-9_]*" ?;
small-ident         = qualifier, ? REGEX "[a-z_][a-zA-Z0-9_]*" ?;
symbol              = ? REGEX "(~!@#\$%^&\*-\+=\\\|:<>\.\?/)+" ?;
operator            = qualifer, symbol - "=", [small-ident], [symbol];
infix-ident         = operator | "`", small-ident, "`";
prefix-ident        = small-ident | "(", operator, ")";
identifier          = small-ident | big-ident | "(", operator, ")"


(* PRAGMAS: *)
allow-unused        = "allow_unused","(", identifier, ")";
warn-unused         = "warn_unused","(", prefix-ident, ")";
inline              = "inline","(", prefix-ident, ")";
deprecated          = "deprecated","(", identifier, [ ",", string ] ")";
test                = "test","(", identifier, ")";
pragma              = "#","[", directive, "]";
pragma-seq          = "#","[", directive, { ",", directive }, "]";
directive           = allow-unused
                    | warn-unused
                    | inline
                    | cold
                    | deprecated
                    | test;
heat-pragma         = "#","[", ("cold"|"warm"), "]";


(* DECLARATION SPECIFIERS: *)
visib               = ["extern"] | ["intern"];
purity              = "pure" | "unsafe" | "impure";
mutab               = ["mut"] | ["imut"];


(* TYPES: *)
type                = "[", type, "]"
                    | big-ident, {type}
                    | small-ident, {type}
                    | "(", type, ",", type, { ",", type } ")"
                    | "(", type, { "->", type }, ")";
constraint          = big-ident, small-ident, {small-ident};
ctx-decl-seq        = constraint, { ",", constraint }, ":";
type-decl-no-ctx    = "<", type, { "->", type }, ">";
type-decl           = "<", [ctx-decl-seq], type, { "->", type }, ">";


(* FUNCTION DEFINITION: *)
func-decl           = visib, purity, prefix-ident, type-decl;
infix-param-seq     = pattern, infix-ident, pattern;
prefix-param-seq    = prefix-ident, {pattern};
func-param-seq      = infix-param-seq | prefix-param-seq;
func-def            = func-param-seq, body-assignment;


(* DATATYPE DEFINITION: *)
field-decl          = small-ident, type-decl;
ctor-def            = visib, big-ident, {type}
                    | visib, big-ident, [ "{", field-decl, { ",", field-decl }, [","], "}" ];
data-def            = visib, "data", big-ident, "=", ctor-def, { "|", ctor-def };
type-alias          = visib, "using", type, "=", type;


(* TRAIT DEFINITION: *)
trait-ctx           = "<", constraint, { ",", constraint }, ">";
trait-decl          = visib, "trait", [trait-ctx], big-ident, small-ident, {small-ident},
                        "{", {(func-decl | func-def)}, "}";
trait-impl          = "impl", [trait-ctx], big-ident, type, {type},
                        "{", {func-decl}, "}";


(* TERMS: *)
infix-call          = term, infix-ident, term | infix-ident, term | term, infix-ident;
(* for now, lambas will be extremely limited due to
it needing `statement` or `body`, which needs `term`
(and thus `lambda'), causing a circular import. Also,
maybe it should have a unique-ish prefix for efficiency? *)
lambda              = {small-ident}, "=>", term;
tuple               = "(", term, ",", term, { ",", term }, ")";
array               = "[", {term}, "]";
prefix-caller       = prefix-ident | ("(", lambda, func-app ")");
func-app            = prefix-caller, {term},
                    | big-ident, {term}
                    | infix-call
term                = literal | func-app | lambda | "(", term, ")";


(* PATTERNS *)
ctor-pattern        = big-ident, {pattern};
tuple-pattern       = "(", pattern, ",", pattern, { ",", pattern }, ")";
pattern-item        = literal | tuple-pattern | ctor-pattern;
pattern             = "_" | small-ident | "[", pattern-item, { ",", pattern-item }, "]";


(* STATEMENTS: *)
statement           = if-else | match | return | loop | new-var, ";" | reassignment, ";";
body                = "{", {statement}, "}";
body-assignment     = "=", statement | body;
stmt-body           = statement | body;
if-else             = "if", [heat-pragma], "(", term, ")", stmt-body,
                        [ "else", [heat-pragma], stmt-body ];
return              = "return", ( term, ";" | match | if-else );
case                = [heat-pragma], pattern, body-assignment;
match               = "match","(", term, ")","{", case, {case}, "}";
loop-clause         = "(", [ term, ";" ], term, [ ";", term ], ")";
loop                = "loop", loop-clause, stmt-body;
var-decl-seq        = "let", mutab, small-ident, [type-decl];
assignment          = "=", term;
new-var             = var-decl-seq, assignment;
reassignment        = small-ident, assignment;
