(* LITERALS: *)
bin                 = ? REGEX "0[bB][01]+" ?;
oct                 = ? REGEX "0[oO]\O+" ?;
hex                 = ? REGEX "0[xX]\x+" ?;
b36                 = ? REGEX "0[aA][a-zA-Z0-9]+" ?;
dec                 = ? REGEX "\d+" ?;
unsigned            = bin | oct | hex | b36 | dec;
integer             = ["-"], unsigned;
float               = integer, [ ".", unsigned ];
char                = "'", character, "'";
unicode             = ? REGEX "\\[uU][0-9a-fA-F]{4}";
hex-character       = ? REGEX "\\[xX][0-9a-fA-F]{2}";
oct-character       = ? REGEX "\\[xX][0-8]{3}";
character           = unicode | hex-character | oct-character | ? REGEX "(\\[\\nrtvf])|.)" ?;
string              = """, {character}, """;
literal             = integer | float | char | string | array;


(* IMPORTING: *)
(* ignore import lists for now *)
(* func-import-list    = prefix-ident, [ ",", func-import-list ], [","]; *)
(* ctor-import-list    = big-ident, [ ",", ctor-import-list ], [","]; *)
import-item         = "trait", big-ident, [ "{", [func-imp-list], "}" ];
                    | "data", big-ident, [ "{", [ctor-imp-list], "}" ];
                    | prefix-ident
module-import       = "import", visib, big-ident, [ "as", big-ident ], [ "using",
                        "{", {import-item}, "}" ];


(* IDENTIFIERS: *)
qualifier           = ? REGEX "([A-Z][a-zA-Z0-9]*\.)*" ?;
big-ident           = qualifier, ? REGEX "[A-Z][a-zA-Z0-9_]*" ?;
small-ident         = qualifier, ? REGEX "[a-z_][a-zA-Z0-9_]*" ?;
symbol              = ? REGEX "(~!@#\$%^&\*-\+=\\\|:<>\.\?/)+" ?;
operator            = qualifer, symbol - "=", [small-ident], [symbol];
infix-ident         = operator | "`", small-ident, "`";
prefix-ident        = small-ident | "(", operator, ")";
identifier          = small-ident | big-ident | "(", operator, ")"


(* PRAGMAS: *)
allow-unused        = "#["allow_unused","(", identifier, ")]";
warn-unused         = "#["warn_unused","(", prefix-ident, ")]";
must-use            = "#["must_use","(", prefix-ident, ")]";
inline              = "#["inline","(", prefix-ident, ")]";
cold                = "#["cold","(", prefix-ident, ")]";
deprecated          = "#["deprecated","(", identifier, [ ",", string ] ")]";
test                = "#["test","(", identifier, ")]";


(* ATTRIBUTES: (NOT YET READY) *)


(* DECLARATION SPECIFIERS: *)
visib               = ["extern"] | ["intern"];
purity              = "pure" | "unsafe" | "impure";
mutab               = ["mut"] | ["imut"];


(* TYPE DECLARATION: *)
(* ignore mutab for now *)
type                = [mutab], "[", type, "]"
                    | [mutab], big-ident, {type}
                    | [mutab], small-ident, {type}
                    | [mutab], "(", type, ",", type, { ",", type } ")"
                    | "(", type, { "->", type }, ")";
constraint          = big-ident, small-ident, {small-ident};
ctx-decl-seq        = constraint, { ",", constraint }, ":";
type-decl           = "<", [ctx-decl-seq], type, { "->", type }, ">";


(* FUNCTION DEFINITION: *)
func-decl           = visib, purity, prefix-ident, type-decl;
infix-param-seq     = pattern, infix-ident, pattern;
prefix-param-seq    = prefix-ident, {pattern};
func-param-seq      = infix-param-seq | prefix-param-seq;
func-def            = func-param-seq, body-assignment;


(* DATATYPE DEFINITION: *)
ctor-def            = big-ident, [type-decl];
data-decl           = visib, "data", big-ident;
data-def            = data-decl, "=", ctor-def, { "|", ctor-def };
type-decl-name      = [mutab], big-ident, {type};
type-alias          = visib, "using", type-decl-name, "=", type;


(* TRAIT DEFINITION: *)
trait-ctx           = "<", constraint, { ",", constraint }, ">";
trait-decl          = visib, "trait", [trait-ctx], big-ident, small-ident, {small-ident},
                        "{", {(func-decl | func-def)}, "}";
trait-impl          = "impl", [trait-ctx], big-ident, type, {type},
                        "{", {func-decl}, "}";


(* TERMS: *)
infix-call          = term, infix-ident, term | infix-ident, term | term, infix-ident;
(* for now, lambas will be extremely limited due to
it needing `statement` or `body`, which needs `term`
(and thus `lambda'), causing a circular import *)
lambda              = {small-ident}, "=>", term;
tuple               = "(", term, ",", term, { ",", term }, ")";
array               = "[", {term}, "]";
term                = literal | infix-call | small-ident | lambda | "(", term, ")" | term, {term};


(* PATTERNS *)
ctor-pattern        = big-ident, {pattern};
tuple-pattern       = "(", pattern, ",", pattern, { ",", pattern }, ")";
pattern-item        = literal | tuple-pattern | ctor-pattern;
pattern             = "_" | small-ident | "[", pattern-item, { ",", pattern-item }, "]";


(* STATEMENTS: *)
statement           = if-else | match | return | loop | new-var, ";" | reassignment, ";";
body                = "{", {statement}, "}";
body-assignment     = "=", statement | body;
stmt-body           = statement | body;
if-else             = "if","(", term, ")", stmt-body, [ "else", stmt-body ];
return              = "return", ( term, ";" | match | if-else );
case                = pattern, body-assignment;
match               = "match","(", term, ")","{", case, {case}, "}";
loop-clause         = "(", [ term, ";" ], term, [ ";", term ], ")";
loop                = "loop", loop-clause, stmt-body;
var-decl-seq        = "let", mutab, small-ident, [type-decl];
assignment          = "=", term;
new-var             = var-decl-seq, assignment;
reassignment        = small-ident, assignment;
